{
  "StorageUploadWithoutLengthCheck": {
    "methodsToCheck": [
      "upload",
      "uploadWithResponse"
    ],
    "antiPatternMessage": "Azure Storage upload API without length parameter detected. Use upload API with length parameter instead.",
    "recommendationText": "Use Upload APIs that take a length parameter. Otherwise, buffering the entire payload in memory can lead to OutOfMemoryErrors, especially when dealing with large files or high-volume uploads",
    "recommendationLink": "https://learn.microsoft.com/azure/storage/blobs/storage-blob-upload-java"
  },
  "DisableAutoCompleteCheck": {
    "methodsToCheck": "disableAutoComplete",
    "clientsToCheck": [
      "ServiceBusReceiverClient",
      "ServiceBusReceiverAsyncClient",
      "ServiceBusProcessorClient"
    ],
    "antiPatternMessage": "Auto-complete enabled by default. Use the disableAutoComplete() API call to prevent automatic message completion.",
    "recommendationText": "Explicitly Disable Auto-Complete: When creating ServiceBusReceiver or Processor clients,  explicitly use the  disableAutoComplete() method call to prevent automatic message completion in cases of failure or error.",
    "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.messaging.servicebus.servicebusclientbuilder.servicebusreceiverclientbuilder?view=azure-java-stable#com-azure-messaging-servicebus-servicebusclientbuilder-servicebusreceiverclientbuilder-disableautocomplete()"
  },
  "DynamicClientCreationCheck": {
    "methodsToCheck": [
      "buildClient",
      "buildAsyncClient"
    ],
    "antiPatternMessage": "Dynamic client creation detected. Create a single client instance and reuse it instead.",
    "recommendationText": "Instead of creating a new client instance for each operation, consider reusing existing client instances. It's recommended to create client instances once and reuse them throughout the application's lifecycle. This approach can lead to better performance and efficiency.",
    "recommendationLink": "https://learn.microsoft.com/azure/developer/java/sdk/overview#connect-to-and-use-azure-resources-with-client-libraries"
  },
  "HardcodedAPIKeysAndTokensCheck": {
    "servicesToCheck": [
      "AzureKeyCredential",
      "AccessToken",
      "KeyCredential",
      "AzureNamedKeyCredential",
      "AzureSasCredential",
      "AzureNamedKey",
      "ClientSecretCredentialBuilder",
      "UsernamePasswordCredentialBuilder",
      "BasicAuthenticationCredential"
    ],
    "antiPatternMessage": "DefaultAzureCredential is recommended for authentication if the service client supports Token Credential (Entra ID Authentication). If not, then use Azure Key Credential for API key based authentication.",
    "recommendationText": "DefaultAzureCredential is recommended for authentication if the service client supports Token Credential (Entra ID Authentication). If not, then use Azure Key Credential for API key based authentication.",
    "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.identity.defaultazurecredential?view=azure-java-stable"
  },
  "GetSyncPollerOnPollerFluxCheck": {
    "methodsToCheck": "getSyncPoller",
    "antiPatternMessage": "Use of getSyncPoller() on a PollerFlux detected. Directly use SyncPoller to handle synchronous polling tasks",
    "recommendationText": "Use of getSyncPoller() on a PollerFlux introduces additional complexity by converting an asynchronous polling mechanism to a synchronous one, which should be avoided. It's recommended to use the SyncPoller directly to handle synchronous polling tasks. ",
    "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.core.util.polling.syncpoller?view=azure-java-stable"
  },
  "ServiceBusReceiveModeCheck": {
    "clientsToCheck": [
      "ServiceBusReceiverClient",
      "ServiceBusReceiverAsyncClient",
      "ServiceBusProcessorClient"
    ],
    "methodsToCheck": [
      "receiveMode",
      "prefetchCount"
    ],
    "antiPatternMessage": "A high prefetch value in PEEK_LOCK detected. We recommend a prefetch value of 0 or 1 for efficient message retrieval.",
    "recommendationText": ": Setting the receive mode as PEEK_LOCK with a high prefetch value  can result in suboptimal performance, message lock expiry and potential data loss which may require additional handling to recover these messages",
    "recommendationLink": "https://learn.microsoft.com/azure/service-bus-messaging/service-bus-prefetch?tabs=dotnet#why-is-prefetch-not-the-default-option"
  },
  "DetectDiscouragedAPIUsageCheck": {
    "ConnectionStringCheck": {
      "methodsToCheck": "connectionString",
      "antiPatternMessage": "Connection String detected. Use DefaultAzureCredential for Azure service client authentication instead if the service client supports Token Credential (Entra ID Authentication).",
      "recommendationText": "DefaultAzureCredential is recommended if the service client supports Token Credential (Entra ID Authentication). if not, then use Azure Key Credential / Connection Strings based authentication",
      "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.identity.defaultazurecredential?view=azure-java-stable"
    },
    "GetCompletionsInChatApplicationsCheck": {
      "methodsToCheck": "getCompletions",
      "antiPatternMessage": "getCompletions API detected. Use the getChatCompletions API instead.",
      "recommendationText": "Use getChatCompletions for Chat Applications: Specifically use getChatCompletions API when generating responses for chatbot or conversational AI applications. The getCompletions API is designed for general-purpose completion tasks. whereas getChatCompletions is specifically optimized for conversational contexts.",
      "recommendationLink": "https://learn.microsoft.com/java/api/overview/azure/ai-openai-readme?view=azure-java-preview"
    }
  },
  "DetectDiscouragedClientCheck": {
    "ServiceBusReceiverAsyncClientCheck": {
      "clientsToCheck": "ServiceBusReceiverAsyncClient",
      "antiPatternMessage": "Use of ServiceBusReceiverAsyncClient detected. Use ServiceBusProcessorClient instead.",
      "recommendationText": "Instead of using ServiceBusReceiverAsyncClient, it is recommended to use ServiceBusProcessorClient. The ServiceBusProcessorClient is a higher-level abstraction that simplifies message consumption, making it a more suitable option for most developers and scenarios.",
      "recommendationLink": "https://github.com/Azure/azure-sdk-for-java/blob/main/sdk/servicebus/azure-messaging-servicebus/README.md#when-to-use-servicebusprocessorclient"
    },
    "EventHubConsumerAsyncClientCheck": {
      "clientsToCheck": "EventHubConsumerAsyncClient",
      "antiPatternMessage": "Use of EventHubConsumerAsyncClient detected. Use EventProcessorClient instead which provides a higher-level abstraction that simplifies event processing, making it the preferred choice for most developers.",
      "recommendationText": "Instead of using EventHubConsumerAsyncClient, it is advised to use EventProcessorClient. The EventProcessorClient provides a higher-level abstraction that simplifies event processing, making it the preferred choice for most developers",
      "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.messaging.eventhubs.eventprocessorclient?view=azure-java-stable"
    }
  },
  "SingleOperationInLoopCheck": {
    "methodsToCheck": [
      "detectLanguageBatch",
      "recognizeEntitiesBatch",
      "recognizePiiEntitiesBatch",
      "recognizeLinkedEntitiesBatch",
      "extractKeyPhrasesBatch",
      "analyzeSentimentBatch"
    ],
    "antiPatternMessage": "Single operation found in loop. This SDK provides a batch operation API, use it to perform multiple actions in a single request: ",
    "recommendationText": "A a batch operation API exists in the SDK that can handle multiple actions in one request.",
    "recommendationLink": ""
  },
  "AbstractUpdateCheckpointAsyncChecker": {
    "methodsToCheck": "updateCheckpointAsync"
  },
  "UpdateCheckpointAsyncSubscribeChecker": {
    "methodsToCheck": "subscribe",
    "antiPatternMessage": "Instead of `subscribe()`, call `block()` or `block()` with timeout, or use the synchronous version `updateCheckpoint()`",
    "recommendationText": "If you call subscribe() with updateCheckpointAsync(), you might get the next batch of events before you finish checkpointing the previous batch, or you might have checkpointing of several batches happening out of order. To avoid this, use block() or block() with a timeout, or consider using the synchronous version updateCheckpoint().",
    "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.messaging.eventhubs.models.eventbatchcontext?view=azure-java-stable#com-azure-messaging-eventhubs-models-eventbatchcontext-updatecheckpointasync()"
  },
  "UpdateCheckpointAsyncBlockChecker": {
    "methodsToCheck": [
      "block",
      "block_with_timeout"
    ],
    "antiPatternMessage": "Calling updateCheckpointAsync() without block() will not do anything, use `block()` or `block` operator with a timeout, or consider using the synchronous version `updateCheckpoint().",
    "recommendationText": "Calling updateCheckpointAsync() without block() will not do anything, use `block()` or `block` operator with a timeout, or consider using the synchronous version `updateCheckpoint().",
    "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.messaging.eventhubs.models.eventbatchcontext?view=azure-java-stable#com-azure-messaging-eventhubs-models-eventbatchcontext-updatecheckpointasync()"
  },
  "KustoQueriesWithTimeIntervalInQueryStringCheck": {
    "regexPatterns": {
      "KQL_ANTI_PATTERN_AGO": ".*ago\\(",
      "KQL_ANTI_PATTERN_DATETIME": ".*datetime\\s*\\(",
      "KQL_ANTI_PATTERN_NOW": ".*now\\(",
      "KQL_ANTI_PATTERN_START_OF_PERIOD": ".*startofday\\(\\)|.*startofmonth\\(\\)|.*startofyear\\(\\)",
      "KQL_ANTI_PATTERN_BETWEEN": ".*between\\(datetime\\("
    },
    "antiPatternMessage": "KQL queries with time intervals in the query string detected.",
    "recommendationText": "Consider using the QueryTimeInterval parameter in the client method parameters to specify the time interval for the query. By passing the time range as an argument in the method call, you make it easier to troubleshoot and understand the context of an API call",
    "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.monitor.query.models.querytimeinterval?view=azure-java-stable"
  },
  "EndpointOnNonAzureOpenAIAuthCheck": {
    "methodsToCheck": [
      "endpoint",
      "credential"
    ],
    "servicesToCheck": "KeyCredential",
    "antiPatternMessage": "Endpoint should not be used with KeyCredential for non-Azure OpenAI clients",
    "recommendationText": "Omit Endpoint: Only specify the endpoint parameter if you are working with Azure OpenAI services that require it. Otherwise, it is not necessary to authenticate non-Azure Open-AI clients.",
    "recommendationLink": "https://learn.microsoft.com/java/api/com.azure.core.credential.keycredential?view=azure-java-stable"
  }
}
